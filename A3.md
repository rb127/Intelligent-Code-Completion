# Assignment 3 - Team JavaSlipt

*For more artifacts or insights into the decision making process, please see our meeting minutes (linked in README).

## A Disclaimer (sort of)
 - Our project was structured to focus on detailed planning and testing for Milestones 1 and 2 (A1 and A2)
 - We spent large amounts of time testing into the future and also changing plans during A1 and A2 to ensure minimum changes during A3
 - A3 (milestone 3) was intended to be a coding sprint with little to no changes in structure and ideas, so a lot of our decisions were made and explained earlier and are just implemented here.
 - Please refer to A1.md and A2.md for detailed explanations for these decisions

## A Final Overview of the Features implemented by our project:

- **Parse a JavaScript Program and Extract Class Names, Method Names, and Variable Names taking scope into account**
  * Description:
    - This is the fundamental block of our program, this feature basically is the engine for our entire program. Firstly, we provide a .js file to our program converted to a string. From this string file, we extract the user's 'search string' from our parser (acorn-loose) and mocked cursor position (using a predefined special character that is treated as a cursor). Then, we parse the incomplete program through acorn-loose, which gives us an ES Tree of the nodes and blocks of the program.  Using this parsed ES Tree, cursor position and reference string, we find the nearest node to the cursor and move upwards from there. We then use 'acorn-walk' to walk through this ES Tree and extract the relevant classes, methods, and variables from the program. 
    - Scope is ingrained into our process - the ES Tree given to us by the acorn-loose library is hierarchally nested by scope. When we use acorn-walk to traverse this to retrieve information, we only go 'up' in scope. This ensures we never suggest any out of scope items but also that our suggestions are initially ordered scope-wise, with nearer scope suggested first.
  * Acceptance criteria: 
    - Return an empty list of suggestions if the .js file provided is empty
    - Return an empty list of suggestions if the cursor has no character/string preceeding it (empty search string)
    - Return an empty list of suggestions if no matches are found for the given search string
    - Return an empty list of suggestions if the cursor is in commented code
    - Return appropriate list of suggestions even if the code is broken/incomplete before or after the cursor
    - Include matching import libraries in the suggestions list (only those that are imported)
    - The suggestions list should be ordered by scope, with most local (accessible) being suggested first
    - The suggestions list should not include variables from scopes that are not referencable
    - The suggestions list should include function names, class names, and variables names (apart from import statements)
   * Acceptance demonstration:
     - Acceptance tests verified by client in test/acceptance.spec.js
   * Acceptance criteria completed?
     - We have met all our acceptance criteria for this feature
   * Changes from plan:
     - None
   * Contributors:
     - Rohit (Implementation)
     - Shahmir (Implementation)
     - Chinmaya (Infrastructure set-up and retrieval of reference string)


- **Approximate (Fuzzy) String Matching**
  * Description:
    - This feature is used to search our suggestions list received from Feature 1 above for the user's reference string based on their cursor position. We used Fuzzy searching intead of identical matching to have some tolerance for typos and 'smartly' suggest relevant suggestions. To implement this feature, we provide a suggestions list (that we get from Feature 1), the user's search string (based on preceeding characters before cursor position) to our stringMatching method, an optional threshold score which provides the level of error tolerance in fuzzy searching, and an optional order by scope true/false flag which determines whether to order the final suggestions list to the user by search relevance or scope.
    - We use Fuse.js to perform Fuzzy Search for us. We chose Fuse.js because it is extremely light-weight (and hence fast), has amazing documentation, suppotrs many helpful flags (such as a threshold score and a flag to order by relevance or not). In our testing where we compared Fuzzy searching libraries to VSCode's autocomplete fuzzy searching, we found Fuse.js to be the most similar. 
  * Acceptance criteria: 
    - Return empty list if the universe array is empty
    - Return empty list if the search string is empty
    - Return exact matches when threshold is set to 0
    - Return reasonable matches when threshold is set to 0.5
    - Return reasonable matches ordered by scope when threshold is set to 0.5 and orderedByScope is True
   * Acceptance demonstration:
     - Unit tests in test/stringMatching.spec.js
     - These tests are not verified by our client but our initial plan was verified by them (details about plan changes below) - and we have built on top of that functionality (that is, we still have options/flags (threshold score & order by scope) that can be set to revert to our original behaviour)
   * Acceptance criteria completed?
     - We have met all our acceptance criteria for this feature
   * Changes from plan:
     - Our initial plan was to have exact string matching instead of fuzzy string matching. We thought that we would return the suggestions list to the user with suggestions that had the exact seatch phrase present in them and ordered by scope.
     - As we did more and more research on this, we realised that most code autocomplete libraries give relevance much much more importance than scope (VSCode doesn't even give scope any importance for ordering). This led us to change track and order our suggestions by relevance by default. We have an option which we can set to order by scope though.
     - We used fuzzy searching instead of exact matching because typos are frequent while typing out programs and we wanted to be tolerant to them - this seems like a more practical approach for a real world autocompletion library. Again here, we have a flag that we can give our fuzzy searching method to have a '0' error-tolerance which basically makes it exact string matching
   * Contributors:
     - Chinmaya


- **Support for JavaScript Reserved Words**
  * Description:
    - This feature simply adds a list of supported JavaScript keywords/reserve words as per ECMA Script 5/6 to our suggestions list before using Feature 2 to search through it.
  * Acceptance criteria: 
    - Add a list of the given ECMA Script 5, 6 reserve words to the intermediate suggestions list.
   * Acceptance demonstration:
     - Acceptance tests for Feature 1 included tests to demonstrate that this feature works
   * Acceptance criteria completed?
     - We have met all our acceptance criteria for this feature
   * Changes from plan:
     - We were unsure whether or not to add 'live' keyword support before A3. In other words, as new keywords are added, we strived to be able to automatically update our keywords list to include these new keywords (and possibly remove old ones that are no longer keywords). However, we decided against this and chose to continue with a static list of current JavaScript keywords instead.
     - Reasons for this were - we tried hard to search for an API that simply gave us current JavaScript keywords but could not find an API that did this (potentially a CSC302 Winter 2022 project suggestion). The other approach of webscraping a page to retreive current keywords (such as this one: https://www.w3schools.com/js/js_reserved.asp) were impractical for us because we didn't believe it offered a good time vs utility return. All 3 of us do not have great experience with JavaScript and trying to webscrape using it would have taken a long time. Using a scripting language such as Python to do this would have added unnecessary complexity to our repository and we did not feel the utility added was significant enough to justify these cons. Instead, we focussed on other features with a better time-utility return.
   * Contributors:
     - Chinmaya

- **Getting cursor position from a .js file**
  * Description:
    - We use a special character that has no meaning in JavaScript (Lambda Character) to mimic a cursor. To get the cursor position to give to our program, we perform searching on a string (using indexOf) to find this 'cursor'. We also have an option to easily change this special character (it is a const variable) if the character we choose has any meaning in JavaScript in the future.
    - Assumptions include - either 0 or 1 cursor possible, the special character is not used for anything else
  * Acceptance criteria: 
    - Return a cursor positon from a given string
   * Acceptance demonstration:
     - Acceptance tests for Feature 1 included tests to demonstrate that this feature works
     - There are also unit tests to demonstrate this in cursorPosition.spec.js
   * Acceptance criteria completed?
     - We have met all our acceptance criteria for this feature
   * Changes from plan:
     - None
   * Contributors:
     - Rohit


- **Getting a reference string from a .js file based on the cursor position**
  * Description:
    - Using the cursor position retrieved above and the parsed ES Tree program, retrieve the reference string (the character's before the cursor) to use as a search phrase for autocomplete. To do this, we used acorn-walk's find nearest node functionality which takes a cursor position and then returns the nearest node to it. From this nearest node, we found the closest 'Identifier' type to find the reference string.
  * Acceptance criteria: 
    - Return a reference string preceeding the charcters of the 'mock' cursor
    - If there is a whitespace before the cursor, there is no search string
    - If there is no whitespace before the cursor, all the characters left of it to the nearest whitespace are the search string 
   * Acceptance demonstration:
     - Acceptance tests for Feature 1 included tests to demonstrate that this feature works
     - There are also unit tests to demonstrate this in referenceString.spec.js
   * Acceptance criteria completed?
     - We have met all our acceptance criteria for this feature
   * Changes from plan:
     - None
   * Contributors:
     - Shahmir

**Note: This was a very cumulative project and most features were pair-programmed, contributors are largely correct but should be taken with a grain of salt**


## Post-mortem on Assignment 2 (((((((((TBD))))))))

### What goals have been achieved?

- The goals in A1 were very process & planning intensive - we wanted to arrive at design decisions and find libraries and we were largely able to do that.
- The most important part of our project was finding a JS code parser that can also handle incomplete code. We struggled to find a parser that worked reliably with incomplete code initially but after a wild goose chase and many others that didn’t work, we found ‘acorn-loose’ which seemed to work reliably with both incomplete and complete code. 
- Testing the library we were using as the parser was of paramount importance. We were able to use the VSCode debugger tool effectively to give the library different types of code & confirm it worked as we wanted.
- The third thing we achieved in A1 was setting out a plan for the flow of control and how we would interact with the user. We arrived at a design decision (the user will provide a .js file and an integer cursor position and we will use this information to parse the code contextually aware of where the cursor is). We also decided that we would provide a list with matching suggestions to the user's output.
- We were also able to plan and concretely layout our milestones and split up tasks as required by the specifications of the stakeholders. However, we found that these initial milestones were very feature-driven (Discussed in next section).

### What goals have been missed, and by how much?

We don’t think we concretely missed any goals but identified a few areas we would have done differently if we had the option to start over.

- As we worked on A2, we realized that our milestones were extremely feature-driven & not process driven. We realised that our milestones were not capturing any groundwork that would have to be done pre-feature implementation and for our project this was a large chunk of work. We also identified that our milestone had no indication of testing. As we worked harder & harder on the groundwork and testing for A2, we realised that our milestones were not capturing the amount of groundwork we had already put in. This feeling was also reinforced by Greg, our client, who pushed us to focus on Test Driven Development (TDD) and have a blueprint of test cases for A2 that would pass at the end of our project. This emphasised that we could have formulated milestones from more of a developer’s perspective rather than our initial approach of being very feature and consumer/client driven.

- During A1, we assumed that we would “pre-parse” the entire program and keep a data-structure with auto-suggestion results pre-formed to improve efficiency during running the program. However, as we began to think deeper about the flow of control and implementation of the program, we realised that this approach would be very resource-intensive and a large portion of the resources used would not even be utilised. To go ahead with this approach, we would basically have to have a preformed list for every reasonable position of the cursor and then just search for the result based on the actual cursor position. We found that this did not make sense and would take a huge amount of time during the initial run. We also realised that our pre-formed list would be rendered useless each time the input JS code was changed so we have now opted for a ‘live-filled’ implementation plan instead.

- Our final area of improvement identified was for the way the user interacts with the program. We planned for user-input using the cursor position given by the user in an integer format. However, as we ourselves used this format for testing, we realized that this is not the best way to expect the user to provide input as it was extremely cumbersome. We decided to switch to a special character that would mimic the cursor and will add a layer of abstraction to our program which will search for the special character in the input and give our ‘backend’ the integer position of the special character.


### How plans were adjusted, in light of that information, including goals or features that were dropped.

We still feel we can deliver on the milestones mentioned in A1 largely. However, there has been some re-scoping with how they are structured. The end-goal remains very similar with almost identical features as planned above even though the process of arriving there and the order of priorities may have changed. We underestimated the significance of the groundwork required to start concretely implementing features straightaway in an efficient way. Consulting with our industry partner also made us realise what we should focus on.


**As a recap, our milestones as of A2 and verified by our client were:
- **Milestone 1:** Finding and testing a reliable parser which works with incomplete code and using this to inform a rough implementation plan and control-flow of the program
- **Milestone 2:** Setting up the infrastructure required to enable easy and efficient development (input files, cursor position, testing), agreeing on a acceptance testing suite with our client, having a detailed implementation idea, and implementing the aforementioned testing-suite to have a concrete set of requirements to pass after Milestone 3
- **Milestone 3:** Implement the actual code and pass the tests written in Milestone 2
  * Incomplete/broken code support
  * Autocomplete suggestions sorted by most immediate scope
  * Support for keywords (updated automatically if keywords are added and removed from JavaScript)
  * Tolerant (possibly) string searching of the autocomplete ‘master list’
  * Providing a .js file and with a cursor special character and receiving an output list ordered by scope and relevance
